# 哈希表(Hash Table)

在计算机科学中, 一个 *** 哈希表(hash table 或 hash map) *** 是一种实现 ```关联数组(associative array)``` 的抽象数据; 类型, 该结构可以将 ```键映射到值```

哈希表是使用 ```哈希函数/散列函数``` 来计算一个值在数组或桶(buckets)中或槽(slots)中对应的索引, 可使用该索引找到所需的值.

通俗来说: 散列表, 又名哈希表, 是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构. 也就是说, 把关键字映射到一个表中的位置来直接访问记录, 以加快访问速度.

## 哈希表的存储结构

哈希表是使用 ```散列表``` 的存储结构来存储在内存中. 散列表是一种使用空间换时间的存储结构, 因为要在内存中多增加一个存储它们所对应的映射关系. 但如果所需空间过大也会让人头疼, 所以通常在时间或空间二者之间权衡.

## 生活中的散列表

生活中也有很多散列表的使用场景. 比如我们要在微信的通讯录中查找一个人, 我们也不会按照字母表的顺序去一个一个人这样查找. 因为这样做实在太慢了. 但现实中我们其实是这样做的: 首先看这个人的名字的首字母是什么, 比如说姓张, 那么我们肯定会滑到 ```Z``` 栏.

其实这里就用到了散列表的思想.

## 哈希函数的实现方法

哈希函数比较常用的实现方法比较多, 通常只需要考虑几个因素: 关键字的长度, 哈希表的大小, 关键字的分布情况, 记录的查找频率, 等等.

下面介绍几种哈希函数: (其余自行google)

- 直接寻址法: 取关键字或关键字的某个线性函数值为散列地址.
- 数字分析法: 通过对数据的分析, 发现数据中冲突较少的部分, 并构造散列地址. 例如同学们的学号, 通常同一届学生的学号, 其中前面的部分差别不太大, 所以用后面的部分来构造散列地址.
- 平方取中法: 当无法确定关键字里哪几位的分布相对比较均匀时, 可以先求出关键字的平方值, 然后按需要取平方值的中间几位作为散列地址. 这是因为: 计算平方之后的中间几位和关键字中的每一位都相关, 所以不同的关键字会以较高的概率产生不同的散列地址.
- 取随机数法: 使用一个随机函数, 取关键字的随机值作为散列地址, 这种方式通常用于关键字长度不同的场合.
- 除留取余法: 取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址. 这种方式也可以在用过其他方法后再使用. 该函数对 m 的选择很重要, 一般取素数或者直接用 n.

## 散列函数产生冲突的解决办法

散列表为什么会差生冲突? 因为有时不同的 Key 通过哈希函数可能会得到相同的地址, 这在我们操作时可能会对数据造成覆盖, 丢失. 之所以会产生冲突是由于哈希函数有时对不同的 Key 进行计算之后获得了相同的地址.

冲突的处理方法也有很多, 下面介绍几种: (其余自行google)

- 开放地址法: 实际上就是当需要存储值时, 对 Key 哈希之后, 发现这个地址已经有值了, 不能放到这个地址, 不然之前的映射会被覆盖. 这时对计算出来的地址进行一个探测再哈希, 比如往后移动一个地址, 如果没人占用, 就使用这个地址. 如果超过最大长度, 则可以对总长度取余.
- 再哈希法: 在产生冲突之后, 使用关键字的其他部分继续计算地址, 如果还是有冲突, 则继续使用其他地址再计算地址. 这种方式的缺点是计算成本高了, 时间也增加了.
- 链地址法: 链地址法其实就是对Key通过哈希之后落到同一个地址上的值, 做一个链表. 其实在很多高级语言中, 也是使用这种方法处理冲突的.
- 建立一个公共溢出区: 这种方式是建立一个公共溢出区, 当地址存在冲突时, 把新的地址放在公共溢出区里.

## 参考资料

- [散列表（哈希表）及其存储结构和特点详解](http://data.biancheng.net/view/107.html)
- [javascript-algorithms]https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/hash-table/README.md
- [YouTuBe](https://www.youtube.com/watch?v=shs0KM3wKv8&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=4)

YouTuBe中介绍散列函数产生冲突中的其中一个解决办法就是: 链地址法
